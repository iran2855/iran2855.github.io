[{"title":"Hello World","url":"/2024/05/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"用搜索解决问题","url":"/2024/05/11/%E7%94%A8%E6%90%9C%E7%B4%A2%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/","content":"问题的定义问题描述模型一个问题的定义包含五个部分：\n\n1、初始状态$S$ 0  \n\n2、可选动作。在一个给定状态 s, ACTIONS(s) 返回一组可能的动作\n\n状态转移模型。在状态 s 下执行动作 a 之后所到达的状态用RESULT(s,a) 表示。一个状态经过一个动作后来到的下一个状态我们称之为后继状态 。初始状态、动作、状态转移模型构成了状态空间。状态空间构成一幅有向图。路径是从一个状态出发通过一系列动作所经过的状态序列。\n\n目标状态。 \n\n路径花费。每条路径可以有一个花费，用来度量解的好坏。\n\n\n在后续的例题和代码中，都将使用这种模型。\n把所有问题用一个统一的模型表示清楚，就能够用通用的搜索方法来求解。（本节关键点）\n实例1）罗马尼亚寻径问题\n\n2）八皇后问题\n初步认识搜索算法这一部分主要是一些基础知识，为后面学习各种搜索算法做铺垫的\n搜索中的基本概念（没解释的都是字面意思）\n\n父节点（Parent Node）\n\n子节点（Child Node）\n\n叶节点（Leaf Node）\n\n开节点集（Frontier）：在搜索算法中，开节点集是指尚未被探索的节点的集合。这些节点可能是搜索过程中已经发现但尚未扩展的节点，或者是搜索过程中生成的新节点。开节点集通常是搜索算法的主要工作区域，在其中进行节点的扩展和探索。\n\n闭节点集（Closed set）：闭节点集是指已经被探索过的节点的集合。这些节点通常已经被搜索算法考虑过，并且可能已经被标记为已经扩展或者已经排除。闭节点集通常用于避免搜索算法重复探索相同的节点，以提高搜索效率。\n\n搜索策略（search strategy）\n\n\n搜索算法的一般框架大多数搜索方法可以归类为图搜索或树搜索，虽然有些搜索方法可能不严格符合这两种模式，例如启发式搜索（Heuristic Search）。\n树搜索の伪代码：\nfunction TREE-SEARCH(problem) returns a solution, or failure    initialize the frontier using the initial state of problem    loop do        if the frontier is empty then return failure        choose a leaf node and remove it from the frontier        if the node contains a goal state then return the corresponding solution        expand the chosen node, adding the resulting nodes to the frontier\n\n树搜索函数：返回问题的解/无解    初始化：使用问题的初始状态初始化开节点集    然后进入循环        先判断：如果开集为空了，说明找到最后也没有解，故返回无解        如果开集里还有节点，就选择一个叶节点并将其从开集中移除（已经搜过了        如果\n\n图搜索の伪代码：\n后面写\n树和图的区别：\n图搜索要存闭节点集，让搜索的时候不要重复搜索之前展开过的节点，从而防止死循环。\n因为图可以原路返回，树不能从叶子返回父亲节点，这是由于二者连接关系的不同。\n性能评价搜索算法的评价\n从完备性，最优性，时间复杂度，空间复杂度四个方面评价\n（完备性：即如果存在解，该算法是否一定能找到解）\n问题难度的衡量\n\n图搜索：\n\n用状态空间图的大小来衡量问题的规模 |V| + |E|,。其中 V是点数 ，E 边数。\n\n\n树搜索：\n\n用如下两个指标：b, 分支数 branching factor 或者节点所具有的最大子节点数目；d,  depth，最浅的目标状态所在；\n\n\n\n算法复杂度的计算\n\n时间复杂度经常用搜索树展开的节点的数目表示。\n\n空间复杂度通常用需要存储的最大节点数目来估计。\n\n\n无信息搜索（盲目搜索）无信息搜索是指在搜索过程中不使用任何启发信息的搜索方法。无信息搜索方法通常会遍历整个搜索空间，直到找到解或者确定无解。\n宽度优先搜索（BFS）这是一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。并不考虑结果的可能位置，只是暴力彻底地搜索整张图，直到找到结果为止。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。\n解释\n\n如图，对于BFS，遍历顺序是A,B,C,D,E,F,G。\n\n看过一个形象的解释：找人帮忙，BFS是先把自己所有的熟人找一遍，再把所有熟人的熟人找一遍，再找熟人的熟人的熟人……而下面的DFS则是沿着一条关系一直往下找\n\n代码实现储存\n\n对于开节点集，我们使用队列储存，这样便于搜索算法根据搜索策略展开一下个节点；\n\n对于闭节点集，我们使用哈希表储存，这样可以方便的检测重复状态（用hash table查询某个元素是否在闭集中的复杂度是O(1)；\n\n对于树上的每一个节点，我们用一个结构体存储以下四个信息：\n\nn.STATE: 本节点代表的状态；\n\nn.PARENT: 父节点（指向父节点的指针）；\n\nn.ACTION: 父节点到达此节点所采取的动作；\n\nn.PATH-COST: 花费，从根节点到达本节点的路径的花费，传统上用 g(n) 表示。\n\n如图：\n\n\n\n\n\n最终代码\n（注释来自卓佬的超大杯理解）\nfrom copy import deepcopyfrom queue import Queuefrom interface.state import StateBasefrom utils.show_path import show_reversed_path# 定义宽度优先搜索类class BreadthFirstSearch:    # 初始化函数，接受一个状态对象，并验证其为StateBase的实例    def __init__(self, state:StateBase):        assert isinstance(state, StateBase)        self.initial_state = deepcopy(state)  # 使用深拷贝以避免修改原始状态    # 搜索函数，tree_search控制是否使用树搜索，require_path控制是否返回路径    def search(self, tree_search: bool=True, require_path: bool=True) -&gt; None:        states_queue = Queue()  # 状态队列，用于存储待探索的状态        explored_states = set()  # 探索过的状态集合，防止重复探索，图搜索专用        last_state_of = dict()   # 记录每个状态的前一个状态，用于输出整体路径时路径回溯        # 将初始状态加入队列和探索集合        states_queue.put(self.initial_state)        explored_states.add(self.initial_state)        # 当队列非空时，持续处理        while not states_queue.empty():            state = states_queue.get()  # 从队列中获取一个状态            # 如果状态成功，则根据是否需要路径显示不同的信息            if state.success():                if require_path:                    show_reversed_path(last_state_of, state)  # 显示从初始状态到当前状态的路径                else:                    state.show()  # 显示当前状态                continue            # 如果状态失败，继续下一个循环            if state.fail():                continue            # 对当前状态可采取的每个动作进行遍历，这里最外层使用 for 循环保证了广度优先（优先遍历同一层）            for action in state.action_space():                new_state = state.next(action)  # 生成新的状态                # 如果使用树搜索或新状态未被探索过，进行处理                if tree_search:                    states_queue.put(new_state)  # 将新状态加入队列，但不会立刻遍历，因为先要从 for 循环中取出当前节点的所有动作                    if require_path:                        last_state_of[new_state] = state  # 记录路径                # 如果使用图搜索，额外要求新状态未被探索过                elif new_state not in explored_states:                    states_queue.put(new_state)  # 将新状态加入队列                    explored_states.add(new_state)  # 添加到已探索集合                    if require_path:                        last_state_of[new_state] = state  # 记录路径\n\n优缺点缺点：\n\n1、在宽度优先搜索中，内存的需求问题要比运行时间更严重；\n\n2、虽然但是，时间问题仍然是个大问题；\n\n\n优点：\n\n3、路径最短保证：广度优先搜索能够保证在无权图中找到从起点到终点的最短路径。\n\n4、完备性：如果有解，BFS 保证能找到解。因为对于 BFS 来说，解的存在保证了到达解的搜索空间是有限的，也即假设解的路径长度为 d，那么 BFS 一定会在第 d 层找到解。\n\n\n等看了回放再自己写吧\n深度优先搜索（DFS)这是一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。\n解释\n如图，遍历顺序是\nDFS找到的解不一定是最优解，比方说你先找了个远亲帮了你，但实际上还有近邻也能帮你解决问题，但是你还没有去搜索。\n代码实现只要把FIFO队列queue换成先进后出LIFO的栈stack，存下⼀个待展开的点。\n当然，也可使用《计算概率》讲过的递归调用（recursive function）的⽅法。\n最终代码\nfrom copy import deepcopyfrom queue import LifoQueuefrom interface import StateBasefrom utils.show_path import show_reversed_pathclass DepthFirstSearch:    # 初始化函数，接受一个状态对象，并验证其为StateBase的实例    def __init__(self, state: StateBase):        assert isinstance(state, StateBase)        self.initial_state = deepcopy(state)    def search(self, tree_search: bool=True, require_path: bool=True) -&gt; None:        states_stack = LifoQueue()        explored_states = set()        # 将初始状态放入栈中，并记录状态为已探索        # 注意这里存储一个元组，而不是 BFS 的仅存储状态，因为我们要存储当前搜索路径上每个节点的所有下一步可能        # 也即空间复杂度 O(mb) 中的 b        states_stack.put((self.initial_state, 0))        explored_states.add(self.initial_state)        last_state_of = &#123;&#125;        # 这里没有 BFS 内层的 for 循环，直接对整个状态栈遍历        while not states_stack.empty():            state, action_id = states_stack.get()            if state.success():                if require_path:                    # 如果成功达到目标状态，且需要路径，展示从初始状态到当前状态的路径                    show_reversed_path(last_state_of, state)                else:                    # 否则只展示当前状态                    state.show()                continue            if state.fail():                continue  # 如果状态失败，跳过当前循环            if action_id &lt; len(state.action_space()):                # 即将遍历子节点，将当前状态压栈，action_id 记录对于当前状态已经充分探索过的节点个数                # 结束对于一个节点的搜索当且仅当所有子节点都被遍历过，也即 action_id == len(state.action_space())                states_stack.put((state, action_id + 1))                # 探索当前状态下，允许的新状态 state.action_space()[action_id]                new_state = state.next(state.action_space()[action_id])                # 如果是树搜索，将新状态放入栈中                if tree_search:                    # 这句话结合外层的 while 循环保证了会一直尝试深度优先                    states_stack.put((new_state, 0))                    if require_path:                        # 记录下一个状态的前驱状态为当前状态                        last_state_of[new_state] = state                # 如果是图搜索，额外要求新状态未被探索过，才能将新状态放入栈中                elif new_state not in explored_states:                    states_stack.put((new_state, 0))                    explored_states.add(new_state)                    if require_path:                        last_state_of[new_state] = state\n\n深度受限搜索（Depth-Limited Search）对于图搜索的dfs，因为没有存储搜索过的点，可能会陷入死循环（在一个环里转圈）。而深度受限搜索通过限定搜索的最大深度 ，避免了无限循环的发生。\n\n限定搜索的最大深度 为L，则深度为 L的节点会被当作没有后继的叶子节点。\n\n如果 L &lt; d，搜索可能是不完全的。即最浅的解的深度比 L要深。这里 d 是解所在的深度。\n\n如果我们选择 L &gt; d，深度受限搜索也可能不是最优的（如果只找一个解就停止）。它的时间复杂度是 O(bL) ，空间复杂度是 O(bL)。\n\n深度受限搜索可能有两种搜索不成功的情况：真的“没有解”和由于没有搜索\n到足够深度而返回“无解。\n\n\n此外，深度优先搜索可以看成 L &#x3D; ∞ 的深度受限搜索。\n","tags":["课程笔记"]}]